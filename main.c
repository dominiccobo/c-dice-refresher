#include <stdio.h>

#define         true                            1
#define         false                           0

#define         TWO_DIMENSIONAL_FACE_SIZE       5
#define         DICE_TO_USE                     2
#define         CELL_PRINT_SPACING              "  "

/**
 * Structure defining what data is required for the manipulation of a die.
 */
struct Die {
    // storing layout not optimal in large solutions, however proof of concept for explanation..
    char layout[TWO_DIMENSIONAL_FACE_SIZE][TWO_DIMENSIONAL_FACE_SIZE];
    int digitToRoll;
    int isGenerated;
};

/**
 * Define a series of die.
 */
struct Die dice[DICE_TO_USE];

// forward declarations
int is2dCorner(int rowIdx, int colIdx);
int is2dLateral(int rowIdx, int colIdx);
int is2dTopOrBottom(int rowIdx, int colIdx);
int shouldBeSetFor(int rowIdx, int colIdx, int digit);
void generateDiceLayouts();
void printDie(int dieIndex);


int main() {


    dice[0].digitToRoll = 2;
    dice[1].digitToRoll = 6;

    generateDiceLayouts();


    printDie(0);
    printDie(1);

    return 0;
}

/**
 * Generates Dice Layout, assigning characters based on a series of logical principles delegated to
 * other functions.
 */
void generateDiceLayouts() {

    for(int dieIdx = 0; dieIdx < DICE_TO_USE; dieIdx++) {
        for(int rowIdx =  0; rowIdx < TWO_DIMENSIONAL_FACE_SIZE; rowIdx++) {

            for(int colIdx = 0; colIdx < TWO_DIMENSIONAL_FACE_SIZE; colIdx++) {

                if(is2dLateral(rowIdx, colIdx)) {
                    dice[dieIdx].layout[rowIdx][colIdx] = '|';
                }
                else if(is2dTopOrBottom(rowIdx, colIdx)){
                    dice[dieIdx].layout[rowIdx][colIdx] = '-';
                }
                else if(is2dCorner(rowIdx, colIdx)) {
                    dice[dieIdx].layout[rowIdx][colIdx] = '+';
                }
                else {
                    if(shouldBeSetFor(rowIdx, colIdx, dice[dieIdx].digitToRoll)) {
                        dice[dieIdx].layout[rowIdx][colIdx] = 'o';
                    }
                    else{
                        dice[dieIdx].layout[rowIdx][colIdx] = ' ';
                    }

                }
            }
        }
        dice[dieIdx].isGenerated = true;
    }
}

/**
 * Prints out the current layout of the die as generated by the generation function.
 * @param dieIndex index of die in the array of existing dice.
 */
void printDie(int dieIndex) {

    if(0 <= dieIndex < TWO_DIMENSIONAL_FACE_SIZE && dice[dieIndex].isGenerated) {
        for(int rowIdx =  0; rowIdx <  TWO_DIMENSIONAL_FACE_SIZE; rowIdx++) {
            for(int colIdx = 0; colIdx <  TWO_DIMENSIONAL_FACE_SIZE; colIdx++) {

                printf("%c", dice[dieIndex].layout[rowIdx][colIdx]);
                if(colIdx == (TWO_DIMENSIONAL_FACE_SIZE - 1)) printf("\n");
                else printf(CELL_PRINT_SPACING);
            }
        }
        printf("\n\n");
    }
}

/**
 * Evaluates whether the current index is where the corner of a die should
 * be rendered or not.
 * @param rowIdx the row index of the current die to apply logic to
 * @param colIdx the col index of the current die to apply logic to
 * @return boolean evaluation, stating whether or not index is a corner.
 */
int is2dCorner(int rowIdx, int colIdx) {

    // top left corner
    if((rowIdx == 0 && colIdx == 0)) {
        return true;
    }
    // top right corner
    if(rowIdx == 0 && (colIdx == TWO_DIMENSIONAL_FACE_SIZE-1)) {
        return true;
    }
    // bottom left corner
    if((rowIdx == (TWO_DIMENSIONAL_FACE_SIZE-1)) && (colIdx == 0)) {
        return true;
    }
    // bottom right corner
    if((rowIdx == (TWO_DIMENSIONAL_FACE_SIZE-1)) && (colIdx == (TWO_DIMENSIONAL_FACE_SIZE-1))) {
        return true;
    }
    return false;
}

/**
 * Evaluates whether the current index is where the lateral,left and right sides, of a die should
 * be rendered or not.
 * @param rowIdx the row index of the current die to apply logic to
 * @param colIdx the col index of the current die to apply logic to
 * @return boolean evaluation, stating whether or not index is a lateral side.
 */
int is2dLateral(int rowIdx, int colIdx) {

    if(!is2dCorner(rowIdx, colIdx) && (colIdx == 0 || (colIdx == (TWO_DIMENSIONAL_FACE_SIZE-1)))){
        return true;
    }
    return false;
}

/**
 * Evaluates whether the current index is where the lateral,top or bottom sides, of a die should
 * be rendered or not.
 * @param rowIdx the row index of the current die to apply logic to
 * @param colIdx the col index of the current die to apply logic to
 * @return boolean evaluation, stating whether or not index is a top or bottom lateral side.
 */
int is2dTopOrBottom(int rowIdx, int colIdx) {

    if(!is2dCorner(rowIdx, colIdx) && (rowIdx == 0 || (rowIdx == (TWO_DIMENSIONAL_FACE_SIZE-1)))){
        return true;
    }
    return false;
}

/**
 * Determines whether the current row and column index need to be set in order to represent
 * a given digit on a die.
 * @param rowIdx row index of the array to apply logic to
 * @param colIdx column index of the array to apply logic to
 * @param digit digit to apply logic to
 * @return boolean evaluation, stating whether cell ultimately needs to be set or not.
 */
int shouldBeSetFor(int rowIdx, int colIdx, int digit) {

    switch (digit) {
        case 1: {
            if(rowIdx == 2 && colIdx == 2) return true;
            break;
        }
        case 2: {
            if(rowIdx == 1 && colIdx == 1) return true;
            else if(rowIdx == 3 && colIdx == 3) return true;
            break;
        }
        case 3: {
            if(rowIdx == 1 && colIdx == 1) return true;
            else if(rowIdx == 2 && colIdx == 2) return true;
            else if(rowIdx == 3 && colIdx == 3) return true;
            break;
        }
        case 4: {
            if(rowIdx == 1 && colIdx == 1) return true;
            else if(rowIdx == 3 && colIdx == 1) return true;
            else if(rowIdx == 1 && colIdx == 3) return true;
            else if(rowIdx == 3 && colIdx == 3) return true;
            break;
        }
        case 5: {
            if(rowIdx == 1 && colIdx == 1) return true;
            else if(rowIdx == 3 && colIdx == 1) return true;
            else if(rowIdx == 2 && colIdx == 2) return true;
            else if(rowIdx == 1 && colIdx == 3) return true;
            else if(rowIdx == 3 && colIdx == 3) return true;
            break;
        }
        case 6: {
            if((1 <= rowIdx <= 3) && (1 <= colIdx <= 3) && colIdx != 2) return true;
            break;
        }
        default: {
            return false;
        }
    }
    return false;
}